using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CustomerManagementSystem.EventStoreSrouceGenerator;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class AggregatePartialMethodGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Select classes that might be derived from `Event`.
        var declarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsCandidateForGeneration(s),
                transform: static (ctx, _) => GetAggregatesWithEvent(ctx))
            .Where(static symbol => symbol is not (null, null));

        // Generate the source code
        context.RegisterSourceOutput(declarations.Collect(), GenerateSource!);
    }

    private static bool IsCandidateForGeneration(SyntaxNode syntaxNode)
    {
        if (syntaxNode is not RecordDeclarationSyntax recordDeclarationSyntax) return false;

        var x = recordDeclarationSyntax.BaseList?.Types.Any(t =>
        {
            var typeSyntax = t.Type as GenericNameSyntax;
            return typeSyntax is { Identifier.Text: "Event", TypeArgumentList.Arguments.Count: 1 };
        }) ?? false;

        return x;
    }

    private static (INamedTypeSymbol? Event, INamedTypeSymbol Aggregate) GetAggregatesWithEvent(
        GeneratorSyntaxContext context)
    {
// Get the symbol for the record declaration
        var recordDeclaration = (RecordDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(recordDeclaration) as INamedTypeSymbol;

        if (symbol is null)
            return (null, null);

// Check if the base type is generic and is of type `Event`
        if (symbol.BaseType is { Name: "Event", TypeArguments.Length: 1 } baseTypeSymbol &&
            baseTypeSymbol.TypeArguments[0] is INamedTypeSymbol genericArgumentSymbol)
        {
            // Return the type itself and the generic argument
            return (symbol, genericArgumentSymbol);
        }

        return (null, null);
    }

    private class AggregateInfo(string name, string @namespace, bool isSealed)
    {
        public string Name { get; } = name;
        public string Ns { get; } = @namespace;

        public bool IsSealed { get; } = isSealed;

        public IReadOnlyCollection<INamedTypeSymbol> Events { get; set; } = [];

        public override bool Equals(object? obj)
        {
            if (obj is AggregateInfo other)
            {
                return Name == other.Name
                       && Ns == other.Ns
                       && IsSealed == other.IsSealed;
            }

            return false;
        }

        public override int GetHashCode()
        {
            unchecked
            {
                var hash = 17;
                hash = hash * 23 + Name.GetHashCode();
                hash = hash * 23 + Ns.GetHashCode();
                hash = hash * 23 + IsSealed.GetHashCode();
                return hash;
            }
        }
    }

    private static void GenerateSource(SourceProductionContext context,
        ImmutableArray<(INamedTypeSymbol Event, INamedTypeSymbol Aggregate)> derivedTypes)
    {
        var aggregates = derivedTypes
            .Select(t =>
                new AggregateInfo(
                    t.Aggregate.Name, t.Aggregate.ContainingNamespace.ToDisplayString(), t.Aggregate.IsSealed))
            .Distinct()
            .ToImmutableList();

        foreach (var aggregate in aggregates)
        {
            var events = derivedTypes
                .Where(d => d.Aggregate.Name == aggregate.Name &&
                            d.Aggregate.ContainingNamespace.ToDisplayString() == aggregate.Ns)
                .Select(d => d.Event)
                .ToImmutableList();

            aggregate.Events = events;
        }

        foreach (var aggregate in aggregates)
        {
            var sb = new StringBuilder();

            var eventsNamespaces = aggregate.Events
                .Select(e => e.ContainingNamespace.ToDisplayString())
                .Where(e => e != aggregate.Ns)
                .Distinct();

            sb.AppendLine("// <auto-generated/>");

            foreach (var ns in eventsNamespaces)
            {
                sb.AppendLine($"using {ns};");
            }

            sb.AppendLine();
            sb.AppendLine($"namespace {aggregate.Ns};");
            sb.AppendLine();

            var isSealed = aggregate.IsSealed ? " sealed " : " ";
            sb.AppendLine($"public{isSealed}partial class {aggregate.Name}");
            sb.AppendLine("{");

            foreach (var @event in aggregate.Events.OrderBy(e => e.Name))
            {
                sb.AppendLine($"    private partial void Apply({@event.Name} @event);");
            }

            sb.AppendLine("}");

            context.AddSource($"{aggregate.Name}AggregatePartialMethods.g.cs",
                SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }
}
