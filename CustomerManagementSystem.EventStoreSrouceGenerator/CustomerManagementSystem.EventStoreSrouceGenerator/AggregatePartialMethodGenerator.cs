using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CustomerManagementSystem.EventStoreSrouceGenerator;

[Generator]
public class AggregatePartialMethodGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var declarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForCodeGeneration(s),
                transform: static (ctx, _) => GetEventInfoWithAggregateInfo(ctx))
            .Where(static symbol => symbol is not null);

        context.RegisterSourceOutput(declarations.Collect(), GenerateSource!);
    }

    private static bool IsSyntaxTargetForCodeGeneration(SyntaxNode syntaxNode)
    {
        if (syntaxNode is not RecordDeclarationSyntax && syntaxNode is not ClassDeclarationSyntax) 
            return false;

        var baseListTypes = (syntaxNode as TypeDeclarationSyntax)!.BaseList?.Types ?? [];

        foreach (var type in baseListTypes)
        {
            if (type.Type is GenericNameSyntax { Identifier.Text: "IEvent", TypeArgumentList.Arguments.Count: 1 })
                return true;
        }

        return false;
    }

    private static EventInfo? GetEventInfoWithAggregateInfo(GeneratorSyntaxContext context)
    {
        if (context.SemanticModel.GetDeclaredSymbol(context.Node) is not INamedTypeSymbol eventNodeSymbol)
            return null;

        if (!eventNodeSymbol.Interfaces.Any(i => i.Name == "IEvent"))
            return null;

        var aggregateType = eventNodeSymbol.Interfaces.First(i => i.Name == "IEvent").TypeArguments[0];

        var eventInfo = new EventInfo(
            eventNodeSymbol.Name, eventNodeSymbol.ContainingNamespace.ToDisplayString(),
            aggregateType.Name, aggregateType.ContainingNamespace.ToDisplayString(), aggregateType.IsSealed);

        return eventInfo;
    }

    private static void GenerateSource(SourceProductionContext context, ImmutableArray<EventInfo?> eventInfos)
    {
        var nonNullEventInfos = eventInfos
            .Where(x => x.HasValue)
            .Select(x => x!.Value)
            .ToImmutableList();

        var aggregates = nonNullEventInfos
            .Select(ei => new AggregateInfo(ei.AggregateName, ei.AggregateNamespace, ei.IsAggregateSealed))
            .Distinct()
            .ToImmutableList();

        foreach (var aggregate in aggregates)
        {
            var events = nonNullEventInfos
                .Where(ei => ei.AggregateName == aggregate.Name &&
                             ei.AggregateNamespace == aggregate.Ns)
                .Select(ei => new { ei.Name, ei.Ns })
                .OrderBy(ei => ei.Name)
                .ToImmutableList();

            var sb = new StringBuilder();

            var eventsNamespaces = events
                .Select(e => e.Ns)
                .Where(e => e != aggregate.Ns)
                .Distinct();

            sb.AppendLine("// <auto-generated/>");

            foreach (var ns in eventsNamespaces)
            {
                sb.AppendLine($"using {ns};");
            }

            sb.AppendLine();
            sb.AppendLine($"namespace {aggregate.Ns};");
            sb.AppendLine();

            var isSealed = aggregate.IsSealed ? " sealed " : " ";
            sb.AppendLine($"public{isSealed}partial class {aggregate.Name}");
            sb.AppendLine("{");

            foreach (var @event in events)
            {
                sb.AppendLine($"    private partial void Apply({@event.Name} @event);");
            }

            sb.AppendLine("}");

            context.AddSource($"{aggregate.Name}Aggregate.PartialMethods.g.cs",
                SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }

    private readonly record struct EventInfo
    {
        public string Name { get; }
        public string Ns { get; }
        public string AggregateName { get; }
        public string AggregateNamespace { get; }
        public bool IsAggregateSealed { get; }

        internal EventInfo(string name, string ns,
            string aggregateName, string aggregateNamespace, bool isAggregateSealed)
        {
            Name = name;
            Ns = ns;
            AggregateName = aggregateName;
            AggregateNamespace = aggregateNamespace;
            IsAggregateSealed = isAggregateSealed;
        }
    }

    private readonly record struct AggregateInfo(string Name, string Ns, bool IsSealed)
    {
        public readonly string Name = Name;
        public readonly string Ns = Ns;
        public readonly bool IsSealed = IsSealed;
    }
}
