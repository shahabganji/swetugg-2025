using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CustomerManagementSystem.EventStoreSrouceGenerator;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class JsonAttributesEventGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Select classes that might be derived from `Event`.
        var declarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsCandidateForGeneration(s),
                transform: static (ctx, _) => GetRecordDeclarationNamedSymbol(ctx))
            .Where(static symbol => symbol is not null);

        // Combine all derived types into a single list
        var derivedTypes = declarations.Collect();

        // Generate the source code
        context.RegisterSourceOutput(derivedTypes, GenerateSource!);
    }

    private static bool IsCandidateForGeneration(SyntaxNode syntaxNode)
    {
        if (syntaxNode is not RecordDeclarationSyntax declarationSyntax) return false;

        var x = declarationSyntax.BaseList?.Types.Any(t => t.GetText().ToString().StartsWith("IEvent<")) ?? false;
        return x;
    }

    private static INamedTypeSymbol? GetRecordDeclarationNamedSymbol(GeneratorSyntaxContext context)
    {
        // Get the symbol for the record declaration
        var recordDeclaration = (RecordDeclarationSyntax)context.Node;
        if (context.SemanticModel.GetDeclaredSymbol(recordDeclaration) is not INamedTypeSymbol symbol)
            return null;

        return symbol.Interfaces.Any(i => i.ToDisplayString().StartsWith("CustomerManagementSystem.Domain.IEvent<"))
            ? symbol
            : null;
    }

    private static void GenerateSource(SourceProductionContext context, ImmutableArray<INamedTypeSymbol> derivedTypes)
    {
        var eventInterface = derivedTypes.First().Interfaces
            .First(i => i.ToDisplayString().StartsWith("CustomerManagementSystem.Domain.IEvent<"));

        var eventNamespace = eventInterface.ContainingNamespace.ToDisplayString();

        var derivedTypesNamespaces = derivedTypes
            .Select(t => $"using {t.ContainingNamespace.ToDisplayString()};")
            .Where(ns => ns != $"using {eventNamespace};")
            .Distinct();

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine();
        sb.AppendLine("using System.Text.Json.Serialization;");
        foreach (var ns in derivedTypesNamespaces)
        {
            sb.AppendLine(ns);
        }

        sb.AppendLine();
        sb.AppendLine($"namespace {eventNamespace};");
        sb.AppendLine();
        sb.AppendLine("[JsonPolymorphic(IgnoreUnrecognizedTypeDiscriminators = true)]");

        foreach (var derivedType in derivedTypes.Distinct(SymbolEqualityComparer.Default))
        {
            sb.AppendLine($"[JsonDerivedType(typeof({derivedType!.Name}), nameof({derivedType.Name}))]");
        }

        sb.Append($"public partial interface {eventInterface.Name};");
        sb.AppendLine();

        context.AddSource("EventsJsonAttributes.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }
}
