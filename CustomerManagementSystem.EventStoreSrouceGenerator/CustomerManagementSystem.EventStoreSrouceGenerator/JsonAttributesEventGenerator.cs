using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CustomerManagementSystem.EventStoreSrouceGenerator;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class JsonAttributesEventGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Select classes that might be derived from `Event`.
        var declarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsCandidateForGeneration(s),
                transform: static (ctx, _) => GetRecordDeclarationNamedSymbol(ctx))
            .Where(static symbol => symbol is not null);

        // Combine all derived types into a single list
        var derivedTypes = declarations.Collect();

        // Generate the source code
        context.RegisterSourceOutput(derivedTypes, GenerateSource!);
    }

    private static bool IsCandidateForGeneration(SyntaxNode syntaxNode)
    {
        if (syntaxNode is not RecordDeclarationSyntax recordDeclarationSyntax) return false;

        var x = recordDeclarationSyntax.BaseList?.Types.Any(t => t.GetText().ToString().Contains("Event<")) ?? false;
        return x;
    }

    private static INamedTypeSymbol? GetRecordDeclarationNamedSymbol(GeneratorSyntaxContext context)
    {
        // Get the symbol for the record declaration
        var recordDeclaration = (RecordDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(recordDeclaration) as INamedTypeSymbol;

        if (symbol is null)
            return null;

        // Check if it inherits from `Event`
        var baseType = symbol.BaseType;

        return baseType?.ToDisplayString().StartsWith("CustomerManagementSystem.Api.Shared.Event<") == true
            ? symbol
            : null;
    }

    private static void GenerateSource(SourceProductionContext context, ImmutableArray<INamedTypeSymbol> derivedTypes)
    {
        var baseType = derivedTypes.First().BaseType;
        if (baseType == null)
        {
            return;
        }

        var namespaceName = baseType.ContainingNamespace.ToDisplayString();

        var derivedTypesNamespaces = derivedTypes
            .Select(t => $"using {t.ContainingNamespace.ToDisplayString()};")
            .Where(ns => ns.Contains(namespaceName) == false)
            .Distinct();

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine();
        sb.AppendLine("using System.Text.Json.Serialization;");
        foreach (var ns in derivedTypesNamespaces)
        {
            sb.AppendLine(ns);
        }

        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine("[JsonPolymorphic(IgnoreUnrecognizedTypeDiscriminators = true)]");

        foreach (var derivedType in derivedTypes.Distinct(SymbolEqualityComparer.Default))
        {
            sb.AppendLine($"[JsonDerivedType(typeof({derivedType!.Name}), nameof({derivedType.Name}))]");
        }

        sb.Append($"public abstract partial record {baseType.Name}");
        sb.Append(" {");
        sb.Append(" }");
        sb.AppendLine();

        context.AddSource("EventJsonAttributes.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }
}
